<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Handling Missing Data in Nutrition Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="10.3_handling_missing_data_files/libs/clipboard/clipboard.min.js"></script>
<script src="10.3_handling_missing_data_files/libs/quarto-html/quarto.js"></script>
<script src="10.3_handling_missing_data_files/libs/quarto-html/popper.min.js"></script>
<script src="10.3_handling_missing_data_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="10.3_handling_missing_data_files/libs/quarto-html/anchor.min.js"></script>
<link href="10.3_handling_missing_data_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="10.3_handling_missing_data_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="10.3_handling_missing_data_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="10.3_handling_missing_data_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="10.3_handling_missing_data_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#step-1-load-the-dataset-and-libraries" id="toc-step-1-load-the-dataset-and-libraries" class="nav-link active" data-scroll-target="#step-1-load-the-dataset-and-libraries">Step 1: Load the Dataset and Libraries 📦</a></li>
  <li><a href="#step-2-explore-missing-data-patterns" id="toc-step-2-explore-missing-data-patterns" class="nav-link" data-scroll-target="#step-2-explore-missing-data-patterns">Step 2: Explore Missing Data Patterns 🔎</a></li>
  <li><a href="#step-3-prepare-the-data-for-analysis" id="toc-step-3-prepare-the-data-for-analysis" class="nav-link" data-scroll-target="#step-3-prepare-the-data-for-analysis">Step 3: Prepare the Data for Analysis 🛠️</a></li>
  <li><a href="#step-4-technique-1---listwise-deletion" id="toc-step-4-technique-1---listwise-deletion" class="nav-link" data-scroll-target="#step-4-technique-1---listwise-deletion">Step 4: Technique 1 - Listwise Deletion 🚮</a></li>
  <li><a href="#step-5-technique-2---meanmode-imputation" id="toc-step-5-technique-2---meanmode-imputation" class="nav-link" data-scroll-target="#step-5-technique-2---meanmode-imputation">Step 5: Technique 2 - Mean/Mode Imputation 📏</a></li>
  <li><a href="#step-6-technique-3---multiple-imputation" id="toc-step-6-technique-3---multiple-imputation" class="nav-link" data-scroll-target="#step-6-technique-3---multiple-imputation">Step 6: Technique 3 - Multiple Imputation 🔄</a></li>
  <li><a href="#step-7-technique-4---bayesian-imputation" id="toc-step-7-technique-4---bayesian-imputation" class="nav-link" data-scroll-target="#step-7-technique-4---bayesian-imputation">Step 7: Technique 4 - Bayesian Imputation 🌐</a></li>
  <li><a href="#step-8-compare-the-results" id="toc-step-8-compare-the-results" class="nav-link" data-scroll-target="#step-8-compare-the-results">Step 8: Compare the Results 🔍</a></li>
  <li><a href="#step-9-learning-points-and-next-steps" id="toc-step-9-learning-points-and-next-steps" class="nav-link" data-scroll-target="#step-9-learning-points-and-next-steps">Step 9: Learning Points and Next Steps 🎓</a>
  <ul class="collapse">
  <li><a href="#learning-points" id="toc-learning-points" class="nav-link" data-scroll-target="#learning-points">Learning Points</a></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next Steps</a></li>
  <li><a href="#setup-requirements" id="toc-setup-requirements" class="nav-link" data-scroll-target="#setup-requirements">Setup Requirements</a></li>
  <li><a href="#expected-output" id="toc-expected-output" class="nav-link" data-scroll-target="#expected-output">Expected Output</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Handling Missing Data in Nutrition Science</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>🧩📊Welcome to this Jupyter notebook on handling missing data in nutrition science! Missing data is a common challenge in epidemiological studies, especially in nutrition research where variables like dietary intake or biomarkers may be incomplete. In this mini-project, we’ll use the epidemiological dataset from our previous work (n=25,000, age range 45-80) to explore and address missing data.We’ll:</p>
<ul>
<li><strong>Explore missing data patterns</strong> to understand their extent and impact 🕵️</li>
<li><strong>Apply common techniques</strong>: listwise deletion, mean/mode imputation, multiple imputation, and a Bayesian approach 🌐</li>
<li><strong>Compare their impact</strong> on a simple analysis (linear regression for baseline BMI) 📈Let’s dive in and learn how to handle missing data effectively in nutrition science!</li>
</ul>
<section id="step-1-load-the-dataset-and-libraries" class="level2">
<h2 class="anchored" data-anchor-id="step-1-load-the-dataset-and-libraries">Step 1: Load the Dataset and Libraries 📦</h2>
<p>Let’s load the epidemiological dataset and the libraries we’ll need for this analysis. The dataset includes variables like age, sex, smoking, physical activity, social class, BMI, blood pressure, sugar intake, SFA intake, and CVD incidence, with ~8% missing data per variable.</p>
<div id="f45ad977" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import libraries for analysis</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> LabelEncoder</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.experimental <span class="im">import</span> enable_iterative_imputer</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.impute <span class="im">import</span> IterativeImputer</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seaborn style for clean visuals</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the dataset</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">'data/epidemiological_study.csv'</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the first few rows</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>data.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-2-explore-missing-data-patterns" class="level2">
<h2 class="anchored" data-anchor-id="step-2-explore-missing-data-patterns">Step 2: Explore Missing Data Patterns 🔎</h2>
<p>Let’s start by examining the extent and patterns of missing data in our dataset. This will help us understand which variables are most affected and whether the missingness appears random or systematic.</p>
<div id="26e572a6" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate percentage of missing data for each variable</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> data.isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>missing_summary <span class="op">=</span> pd.DataFrame({</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Missing (%)'</span>: missing_data.<span class="bu">round</span>(<span class="dv">2</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Display missing data summary</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Missing Data Summary:"</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(missing_summary[missing_summary[<span class="st">'Missing (%)'</span>] <span class="op">&gt;</span> <span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize missing data patterns</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>sns.heatmap(data.isna(), cbar<span class="op">=</span><span class="va">False</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Missing Data Patterns (Yellow = Missing) 📉'</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Variables'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Participants'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-3-prepare-the-data-for-analysis" class="level2">
<h2 class="anchored" data-anchor-id="step-3-prepare-the-data-for-analysis">Step 3: Prepare the Data for Analysis 🛠️</h2>
<p>We’ll prepare the data for a simple analysis: predicting baseline BMI using age, sex, smoking, physical activity, social class, sugar intake, and SFA intake. First, we need to encode categorical variables and select the relevant columns.</p>
<div id="c04d2681" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select relevant columns for analysis</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>analysis_data <span class="op">=</span> data[[<span class="st">'BMI_Baseline'</span>, <span class="st">'Age'</span>, <span class="st">'Sex'</span>, <span class="st">'Smoking'</span>, <span class="st">'Physical_Activity'</span>, <span class="st">'Social_Class'</span>, <span class="st">'Sugar_Intake'</span>, <span class="st">'SFA_Intake'</span>]].copy()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode categorical variables</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>le <span class="op">=</span> LabelEncoder()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>analysis_data[<span class="st">'Sex'</span>] <span class="op">=</span> le.fit_transform(analysis_data[<span class="st">'Sex'</span>].astype(<span class="bu">str</span>))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>analysis_data[<span class="st">'Smoking'</span>] <span class="op">=</span> le.fit_transform(analysis_data[<span class="st">'Smoking'</span>].astype(<span class="bu">str</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>analysis_data[<span class="st">'Physical_Activity'</span>] <span class="op">=</span> analysis_data[<span class="st">'Physical_Activity'</span>].<span class="bu">map</span>({<span class="st">'Low'</span>: <span class="dv">0</span>, <span class="st">'Medium'</span>: <span class="dv">1</span>, <span class="st">'High'</span>: <span class="dv">2</span>, np.nan: <span class="dv">0</span>})</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>analysis_data[<span class="st">'Social_Class'</span>] <span class="op">=</span> analysis_data[<span class="st">'Social_Class'</span>].<span class="bu">map</span>({<span class="st">'A'</span>: <span class="dv">1</span>, <span class="st">'B'</span>: <span class="dv">2</span>, <span class="st">'C1'</span>: <span class="dv">3</span>, <span class="st">'C2'</span>: <span class="dv">4</span>, <span class="st">'D'</span>: <span class="dv">5</span>, <span class="st">'E'</span>: <span class="dv">6</span>, np.nan: <span class="dv">3</span>})</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define predictors and outcome</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> analysis_data.drop(<span class="st">'BMI_Baseline'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> analysis_data[<span class="st">'BMI_Baseline'</span>]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the first few rows of the prepared data</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>X.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-4-technique-1---listwise-deletion" class="level2">
<h2 class="anchored" data-anchor-id="step-4-technique-1---listwise-deletion">Step 4: Technique 1 - Listwise Deletion 🚮</h2>
<p>The simplest approach to handling missing data is <strong>listwise deletion</strong>, where we remove any row with at least one missing value. This method is easy but can lead to loss of data and potential bias if the missingness is not completely random.</p>
<div id="d8b3dd8c" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply listwise deletion</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>X_listwise <span class="op">=</span> X.dropna()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>y_listwise <span class="op">=</span> y[X_listwise.index]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the number of rows remaining</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original dataset size: </span><span class="sc">{</span>X<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"After listwise deletion: </span><span class="sc">{</span>X_listwise<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit a linear regression model</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>model_listwise <span class="op">=</span> LinearRegression()</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>model_listwise.fit(X_listwise, y_listwise)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Display coefficients</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>coeffs_listwise <span class="op">=</span> pd.DataFrame({</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Predictor'</span>: X_listwise.columns,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Coefficient'</span>: model_listwise.coef_</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Linear Regression Results (Listwise Deletion):"</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coeffs_listwise)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-5-technique-2---meanmode-imputation" class="level2">
<h2 class="anchored" data-anchor-id="step-5-technique-2---meanmode-imputation">Step 5: Technique 2 - Mean/Mode Imputation 📏</h2>
<p>Another common method is <strong>mean/mode imputation</strong>, where we replace missing values with the mean (for numerical variables) or mode (for categorical variables). This preserves the sample size but can underestimate variability.</p>
<div id="35ad4ef3" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a copy of the data for mean/mode imputation</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>X_mean_mode <span class="op">=</span> X.copy()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute numerical variables with mean</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>numerical_vars <span class="op">=</span> [<span class="st">'Age'</span>, <span class="st">'Sugar_Intake'</span>, <span class="st">'SFA_Intake'</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>X_mean_mode[numerical_vars] <span class="op">=</span> X_mean_mode[numerical_vars].fillna(X_mean_mode[numerical_vars].mean())</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute categorical variables with mode</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>categorical_vars <span class="op">=</span> [<span class="st">'Sex'</span>, <span class="st">'Smoking'</span>, <span class="st">'Physical_Activity'</span>, <span class="st">'Social_Class'</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>X_mean_mode[categorical_vars] <span class="op">=</span> X_mean_mode[categorical_vars].fillna(X_mean_mode[categorical_vars].mode().iloc[<span class="dv">0</span>])</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute the outcome variable (BMI_Baseline)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>y_mean_mode <span class="op">=</span> y.fillna(y.mean())</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit a linear regression model</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>model_mean_mode <span class="op">=</span> LinearRegression()</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>model_mean_mode.fit(X_mean_mode, y_mean_mode)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Display coefficients</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>coeffs_mean_mode <span class="op">=</span> pd.DataFrame({</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Predictor'</span>: X_mean_mode.columns,</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Coefficient'</span>: model_mean_mode.coef_</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Linear Regression Results (Mean/Mode Imputation):"</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coeffs_mean_mode)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-6-technique-3---multiple-imputation" class="level2">
<h2 class="anchored" data-anchor-id="step-6-technique-3---multiple-imputation">Step 6: Technique 3 - Multiple Imputation 🔄</h2>
<p>A more sophisticated approach is <strong>multiple imputation</strong>, which creates multiple plausible datasets by imputing missing values, then combines the results. We’ll use <code>IterativeImputer</code> from scikit-learn, which models each variable with missing values as a function of the others.</p>
<div id="811d27c4" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine predictors and outcome for imputation</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>combined_data <span class="op">=</span> X.copy()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>combined_data[<span class="st">'BMI_Baseline'</span>] <span class="op">=</span> y</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply multiple imputation</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>imputer <span class="op">=</span> IterativeImputer(max_iter<span class="op">=</span><span class="dv">10</span>, random_state<span class="op">=</span><span class="dv">11088</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>imputed_data <span class="op">=</span> pd.DataFrame(imputer.fit_transform(combined_data), columns<span class="op">=</span>combined_data.columns)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate predictors and outcome after imputation</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>X_multiple <span class="op">=</span> imputed_data.drop(<span class="st">'BMI_Baseline'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>y_multiple <span class="op">=</span> imputed_data[<span class="st">'BMI_Baseline'</span>]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit a linear regression model</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>model_multiple <span class="op">=</span> LinearRegression()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>model_multiple.fit(X_multiple, y_multiple)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Display coefficients</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>coeffs_multiple <span class="op">=</span> pd.DataFrame({</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Predictor'</span>: X_multiple.columns,</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Coefficient'</span>: model_multiple.coef_</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Linear Regression Results (Multiple Imputation):"</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coeffs_multiple)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-7-technique-4---bayesian-imputation" class="level2">
<h2 class="anchored" data-anchor-id="step-7-technique-4---bayesian-imputation">Step 7: Technique 4 - Bayesian Imputation 🌐</h2>
<p>Finally, let’s use a <strong>Bayesian approach</strong> to impute missing data. We’ll model the data with PyMC, treating missing values as parameters to be estimated, and then use the imputed dataset for regression.</p>
<div id="d55648a2" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a copy of the data for Bayesian imputation</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>X_bayesian <span class="op">=</span> X.copy()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>y_bayesian <span class="op">=</span> y.copy()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify missing values</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>missing_mask_X <span class="op">=</span> X_bayesian.isna()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>missing_mask_y <span class="op">=</span> y_bayesian.isna()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Bayesian imputation model</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> bayesian_imputation:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Priors for observed data means</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    mu_age <span class="op">=</span> pm.Normal(<span class="st">'mu_age'</span>, mu<span class="op">=</span><span class="dv">60</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    mu_sugar <span class="op">=</span> pm.Normal(<span class="st">'mu_sugar'</span>, mu<span class="op">=</span><span class="dv">50</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    mu_sfa <span class="op">=</span> pm.Normal(<span class="st">'mu_sfa'</span>, mu<span class="op">=</span><span class="dv">30</span>, sigma<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    mu_bmi <span class="op">=</span> pm.Normal(<span class="st">'mu_bmi'</span>, mu<span class="op">=</span><span class="dv">27</span>, sigma<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Priors for standard deviations</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    sigma_age <span class="op">=</span> pm.HalfNormal(<span class="st">'sigma_age'</span>, sigma<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    sigma_sugar <span class="op">=</span> pm.HalfNormal(<span class="st">'sigma_sugar'</span>, sigma<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    sigma_sfa <span class="op">=</span> pm.HalfNormal(<span class="st">'sigma_sfa'</span>, sigma<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    sigma_bmi <span class="op">=</span> pm.HalfNormal(<span class="st">'sigma_bmi'</span>, sigma<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Impute missing numerical variables</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    age_imputed <span class="op">=</span> pm.Normal(<span class="st">'age_imputed'</span>, mu<span class="op">=</span>mu_age, sigma<span class="op">=</span>sigma_age, shape<span class="op">=</span>X_bayesian.shape[<span class="dv">0</span>], observed<span class="op">=</span>X_bayesian[<span class="st">'Age'</span>])</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    sugar_imputed <span class="op">=</span> pm.Normal(<span class="st">'sugar_imputed'</span>, mu<span class="op">=</span>mu_sugar, sigma<span class="op">=</span>sigma_sugar, shape<span class="op">=</span>X_bayesian.shape[<span class="dv">0</span>], observed<span class="op">=</span>X_bayesian[<span class="st">'Sugar_Intake'</span>])</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    sfa_imputed <span class="op">=</span> pm.Normal(<span class="st">'sfa_imputed'</span>, mu<span class="op">=</span>mu_sfa, sigma<span class="op">=</span>sigma_sfa, shape<span class="op">=</span>X_bayesian.shape[<span class="dv">0</span>], observed<span class="op">=</span>X_bayesian[<span class="st">'SFA_Intake'</span>])</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    bmi_imputed <span class="op">=</span> pm.Normal(<span class="st">'bmi_imputed'</span>, mu<span class="op">=</span>mu_bmi, sigma<span class="op">=</span>sigma_bmi, shape<span class="op">=</span>y_bayesian.shape[<span class="dv">0</span>], observed<span class="op">=</span>y_bayesian)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sample from posterior</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> pm.sample(<span class="dv">1000</span>, tune<span class="op">=</span><span class="dv">1000</span>, return_inferencedata<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract imputed values (use the mean of the posterior samples)</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>X_bayesian[<span class="st">'Age'</span>] <span class="op">=</span> trace.posterior[<span class="st">'age_imputed'</span>].mean(dim<span class="op">=</span>[<span class="st">'chain'</span>, <span class="st">'draw'</span>]).values</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>X_bayesian[<span class="st">'Sugar_Intake'</span>] <span class="op">=</span> trace.posterior[<span class="st">'sugar_imputed'</span>].mean(dim<span class="op">=</span>[<span class="st">'chain'</span>, <span class="st">'draw'</span>]).values</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>X_bayesian[<span class="st">'SFA_Intake'</span>] <span class="op">=</span> trace.posterior[<span class="st">'sfa_imputed'</span>].mean(dim<span class="op">=</span>[<span class="st">'chain'</span>, <span class="st">'draw'</span>]).values</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>y_bayesian <span class="op">=</span> trace.posterior[<span class="st">'bmi_imputed'</span>].mean(dim<span class="op">=</span>[<span class="st">'chain'</span>, <span class="st">'draw'</span>]).values</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="co"># For categorical variables, use mode imputation (already handled during preparation)</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit a linear regression model</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>model_bayesian <span class="op">=</span> LinearRegression()</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>model_bayesian.fit(X_bayesian, y_bayesian)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Display coefficients</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>coeffs_bayesian <span class="op">=</span> pd.DataFrame({</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Predictor'</span>: X_bayesian.columns,</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Coefficient'</span>: model_bayesian.coef_</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Linear Regression Results (Bayesian Imputation):"</span>)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coeffs_bayesian)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-8-compare-the-results" class="level2">
<h2 class="anchored" data-anchor-id="step-8-compare-the-results">Step 8: Compare the Results 🔍</h2>
<p>Let’s compare the regression coefficients from each method to see how the choice of imputation technique affects the results.</p>
<div id="c57bcc95" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine coefficients from all methods</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>comparison <span class="op">=</span> pd.DataFrame({</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Predictor'</span>: X.columns,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Listwise Deletion'</span>: coeffs_listwise[<span class="st">'Coefficient'</span>],</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Mean/Mode Imputation'</span>: coeffs_mean_mode[<span class="st">'Coefficient'</span>],</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Multiple Imputation'</span>: coeffs_multiple[<span class="st">'Coefficient'</span>],</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Bayesian Imputation'</span>: coeffs_bayesian[<span class="st">'Coefficient'</span>]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the comparison</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Comparison of Regression Coefficients Across Methods:"</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(comparison)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the comparison</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>comparison.set_index(<span class="st">'Predictor'</span>).plot(kind<span class="op">=</span><span class="st">'bar'</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Comparison of Regression Coefficients by Imputation Method 📊'</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Coefficient Value'</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Predictor'</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-9-learning-points-and-next-steps" class="level2">
<h2 class="anchored" data-anchor-id="step-9-learning-points-and-next-steps">Step 9: Learning Points and Next Steps 🎓</h2>
<section id="learning-points" class="level3">
<h3 class="anchored" data-anchor-id="learning-points">Learning Points</h3>
<ul>
<li><strong>Missing Data Patterns</strong>: Visualizing and quantifying missing data helps us understand its extent and potential bias. In our dataset, ~8% of values were missing per variable, distributed randomly</li>
<li><strong>Listwise Deletion</strong>: Simple but reduces sample size (e.g., from 25,000 to fewer rows), potentially introducing bias if missingness is not completely random.</li>
<li><strong>Mean/Mode Imputation</strong>: Preserves sample size but underestimates variability, which can lead to overly confident estimates.</li>
<li><strong>Multiple Imputation</strong>: A more robust method that accounts for uncertainty by creating multiple datasets, often yielding more reliable results.</li>
<li><strong>Bayesian Imputation</strong>: Treats missing values as parameters, providing a probabilistic approach that can capture uncertainty and relationships between variables.</li>
<li><strong>Impact on Analysis</strong>: Different methods led to slight variations in regression coefficients, highlighting the importance of choosing an appropriate technique.</li>
</ul>
</section>
<section id="next-steps" class="level3">
<h3 class="anchored" data-anchor-id="next-steps">Next Steps</h3>
<ul>
<li><strong>Explore Missingness Mechanisms</strong>: Test if the missing data is Missing Completely at Random (MCAR), Missing at Random (MAR), or Missing Not at Random (MNAR).</li>
<li><strong>Advanced Bayesian Models</strong>: Use more complex Bayesian models to impute missing data, incorporating relationships between variables (e.g., hierarchical models).</li>
<li><strong>Sensitivity Analysis</strong>: Compare results with different imputation methods to assess robustness.</li>
<li><strong>Apply to Other Analyses</strong>: Use these techniques in other mini-projects (e.g., epidemiology case study) to improve data quality.</li>
<li></li>
<li><em>Keep exploring data handling techniques to ensure robust analyses in nutrition science! 🥕📉</em></li>
</ul>
<hr>
</section>
<section id="setup-requirements" class="level3">
<h3 class="anchored" data-anchor-id="setup-requirements">Setup Requirements</h3>
<ol type="1">
<li><p><strong>Install Libraries</strong>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> ~/Documents/data-analysis-toolkit-FNS/venv/bin/activate</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install numpy==1.26.4 pandas==2.2.3 matplotlib==3.9.2 seaborn==0.13.2 scipy==1.12.0 pymc==5.16.2 arviz==0.19.0 scikit-learn==1.5.2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Environment</strong>:</p></li>
<li><p>Python 3.9, compatible with Apple Silicon (MPS).</p></li>
<li><p><strong>Dataset</strong>: Ensure <code>data/epidemiological_study.csv</code> is available (generated by <code>create_epi_data.py</code>).</p></li>
</ol>
</section>
<section id="expected-output" class="level3">
<h3 class="anchored" data-anchor-id="expected-output">Expected Output</h3>
<ul>
<li><strong>Missing Data Summary</strong>: Table and heatmap showing the extent of missing data.</li>
<li><strong>Regression Results</strong>: Coefficients from linear regression using each imputation method.</li>
<li><strong>Comparison Plot</strong>: Bar chart comparing coefficients across methods.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>